#!/usr/bin/env python3

import sys
import math
from PIL import Image

# Make a lookup map we can use to find values
colour_map = [
    # Main available colours
    (0x00, 0x00, 0x00, 0),
    (0x80, 0x00, 0x00, 1),
    (0x00, 0x80, 0x00, 2),
    (0x80, 0x80, 0x00, 3),
    (0x00, 0x00, 0x80, 4),
    (0x80, 0x00, 0x80, 5),
    (0x00, 0x80, 0x80, 6),
    (0xc0, 0xc0, 0xc0, 7),

    # "Bright" versions of the main colours
    (0x80, 0x80, 0x80,  8),
    (0xff, 0x00, 0x00,  9),
    (0x00, 0xff, 0x00, 10),
    (0xff, 0xff, 0x00, 11),
    (0x00, 0x00, 0xff, 12),
    (0xff, 0x00, 0xff, 13),
    (0x00, 0xff, 0xff, 14),
    (0xff, 0xff, 0xff, 15),

    # Main block of 256 colours
    (0x00, 0x00, 0x00,  16),
    (0x00, 0x00, 0x5f,  17),
    (0x00, 0x00, 0x87,  18),
    (0x00, 0x00, 0xaf,  19),
    (0x00, 0x00, 0xd7,  20),
    (0x00, 0x00, 0xff,  21),
    (0x00, 0x5f, 0x00,  22),
    (0x00, 0x5f, 0x5f,  23),
    (0x00, 0x5f, 0x87,  24),
    (0x00, 0x5f, 0xaf,  25),
    (0x00, 0x5f, 0xd7,  26),
    (0x00, 0x5f, 0xff,  27),
    (0x00, 0x87, 0x00,  28),
    (0x00, 0x87, 0x5f,  29),
    (0x00, 0x87, 0x87,  30),
    (0x00, 0x87, 0xaf,  31),
    (0x00, 0x87, 0xd7,  32),
    (0x00, 0x87, 0xff,  33),
    (0x00, 0xaf, 0x00,  34),
    (0x00, 0xaf, 0x5f,  35),
    (0x00, 0xaf, 0x87,  36),
    (0x00, 0xaf, 0xaf,  37),
    (0x00, 0xaf, 0xd7,  38),
    (0x00, 0xaf, 0xff,  39),
    (0x00, 0xd7, 0x00,  40),
    (0x00, 0xd7, 0x5f,  41),
    (0x00, 0xd7, 0x87,  42),
    (0x00, 0xd7, 0xaf,  43),
    (0x00, 0xd7, 0xd7,  44),
    (0x00, 0xd7, 0xff,  45),
    (0x00, 0xff, 0x00,  46),
    (0x00, 0xff, 0x5f,  47),
    (0x00, 0xff, 0x87,  48),
    (0x00, 0xff, 0xaf,  49),
    (0x00, 0xff, 0xd7,  50),
    (0x00, 0xff, 0xff,  51),
    (0x5f, 0x00, 0x00,  52),
    (0x5f, 0x00, 0x5f,  53),
    (0x5f, 0x00, 0x87,  54),
    (0x5f, 0x00, 0xaf,  55),
    (0x5f, 0x00, 0xd7,  56),
    (0x5f, 0x00, 0xff,  57),
    (0x5f, 0x5f, 0x00,  58),
    (0x5f, 0x5f, 0x5f,  59),
    (0x5f, 0x5f, 0x87,  60),
    (0x5f, 0x5f, 0xaf,  61),
    (0x5f, 0x5f, 0xd7,  62),
    (0x5f, 0x5f, 0xff,  63),
    (0x5f, 0x87, 0x00,  64),
    (0x5f, 0x87, 0x5f,  65),
    (0x5f, 0x87, 0x87,  66),
    (0x5f, 0x87, 0xaf,  67),
    (0x5f, 0x87, 0xd7,  68),
    (0x5f, 0x87, 0xff,  69),
    (0x5f, 0xaf, 0x00,  70),
    (0x5f, 0xaf, 0x5f,  71),
    (0x5f, 0xaf, 0x87,  72),
    (0x5f, 0xaf, 0xaf,  73),
    (0x5f, 0xaf, 0xd7,  74),
    (0x5f, 0xaf, 0xff,  75),
    (0x5f, 0xd7, 0x00,  76),
    (0x5f, 0xd7, 0x5f,  77),
    (0x5f, 0xd7, 0x87,  78),
    (0x5f, 0xd7, 0xaf,  79),
    (0x5f, 0xd7, 0xd7,  80),
    (0x5f, 0xd7, 0xff,  81),
    (0x5f, 0xff, 0x00,  82),
    (0x5f, 0xff, 0x5f,  83),
    (0x5f, 0xff, 0x87,  84),
    (0x5f, 0xff, 0xaf,  85),
    (0x5f, 0xff, 0xd7,  86),
    (0x5f, 0xff, 0xff,  87),
    (0x87, 0x00, 0x00,  88),
    (0x87, 0x00, 0x5f,  89),
    (0x87, 0x00, 0x87,  90),
    (0x87, 0x00, 0xaf,  91),
    (0x87, 0x00, 0xd7,  92),
    (0x87, 0x00, 0xff,  93),
    (0x87, 0x5f, 0x00,  94),
    (0x87, 0x5f, 0x5f,  95),
    (0x87, 0x5f, 0x87,  96),
    (0x87, 0x5f, 0xaf,  97),
    (0x87, 0x5f, 0xd7,  98),
    (0x87, 0x5f, 0xff,  99),
    (0x87, 0x87, 0x00, 100),
    (0x87, 0x87, 0x5f, 101),
    (0x87, 0x87, 0x87, 102),
    (0x87, 0x87, 0xaf, 103),
    (0x87, 0x87, 0xd7, 104),
    (0x87, 0x87, 0xff, 105),
    (0x87, 0xaf, 0x00, 106),
    (0x87, 0xaf, 0x5f, 107),
    (0x87, 0xaf, 0x87, 108),
    (0x87, 0xaf, 0xaf, 109),
    (0x87, 0xaf, 0xd7, 110),
    (0x87, 0xaf, 0xff, 111),
    (0x87, 0xd7, 0x00, 112),
    (0x87, 0xd7, 0x5f, 113),
    (0x87, 0xd7, 0x87, 114),
    (0x87, 0xd7, 0xaf, 115),
    (0x87, 0xd7, 0xd7, 116),
    (0x87, 0xd7, 0xff, 117),
    (0x87, 0xff, 0x00, 118),
    (0x87, 0xff, 0x5f, 119),
    (0x87, 0xff, 0x87, 120),
    (0x87, 0xff, 0xaf, 121),
    (0x87, 0xff, 0xd7, 122),
    (0x87, 0xff, 0xff, 123),
    (0xaf, 0x00, 0x00, 124),
    (0xaf, 0x00, 0x5f, 125),
    (0xaf, 0x00, 0x87, 126),
    (0xaf, 0x00, 0xaf, 127),
    (0xaf, 0x00, 0xd7, 128),
    (0xaf, 0x00, 0xff, 129),
    (0xaf, 0x5f, 0x00, 130),
    (0xaf, 0x5f, 0x5f, 131),
    (0xaf, 0x5f, 0x87, 132),
    (0xaf, 0x5f, 0xaf, 133),
    (0xaf, 0x5f, 0xd7, 134),
    (0xaf, 0x5f, 0xff, 135),
    (0xaf, 0x87, 0x00, 136),
    (0xaf, 0x87, 0x5f, 137),
    (0xaf, 0x87, 0x87, 138),
    (0xaf, 0x87, 0xaf, 139),
    (0xaf, 0x87, 0xd7, 140),
    (0xaf, 0x87, 0xff, 141),
    (0xaf, 0xaf, 0x00, 142),
    (0xaf, 0xaf, 0x5f, 143),
    (0xaf, 0xaf, 0x87, 144),
    (0xaf, 0xaf, 0xaf, 145),
    (0xaf, 0xaf, 0xd7, 146),
    (0xaf, 0xaf, 0xff, 147),
    (0xaf, 0xd7, 0x00, 148),
    (0xaf, 0xd7, 0x5f, 149),
    (0xaf, 0xd7, 0x87, 150),
    (0xaf, 0xd7, 0xaf, 151),
    (0xaf, 0xd7, 0xd7, 152),
    (0xaf, 0xd7, 0xff, 153),
    (0xaf, 0xff, 0x00, 154),
    (0xaf, 0xff, 0x5f, 155),
    (0xaf, 0xff, 0x87, 156),
    (0xaf, 0xff, 0xaf, 157),
    (0xaf, 0xff, 0xd7, 158),
    (0xaf, 0xff, 0xff, 159),
    (0xd7, 0x00, 0x00, 160),
    (0xd7, 0x00, 0x5f, 161),
    (0xd7, 0x00, 0x87, 162),
    (0xd7, 0x00, 0xaf, 163),
    (0xd7, 0x00, 0xd7, 164),
    (0xd7, 0x00, 0xff, 165),
    (0xd7, 0x5f, 0x00, 166),
    (0xd7, 0x5f, 0x5f, 167),
    (0xd7, 0x5f, 0x87, 168),
    (0xd7, 0x5f, 0xaf, 169),
    (0xd7, 0x5f, 0xd7, 170),
    (0xd7, 0x5f, 0xff, 171),
    (0xd7, 0x87, 0x00, 172),
    (0xd7, 0x87, 0x5f, 173),
    (0xd7, 0x87, 0x87, 174),
    (0xd7, 0x87, 0xaf, 175),
    (0xd7, 0x87, 0xd7, 176),
    (0xd7, 0x87, 0xff, 177),
    (0xd7, 0xaf, 0x00, 178),
    (0xd7, 0xaf, 0x5f, 179),
    (0xd7, 0xaf, 0x87, 180),
    (0xd7, 0xaf, 0xaf, 181),
    (0xd7, 0xaf, 0xd7, 182),
    (0xd7, 0xaf, 0xff, 183),
    (0xd7, 0xd7, 0x00, 184),
    (0xd7, 0xd7, 0x5f, 185),
    (0xd7, 0xd7, 0x87, 186),
    (0xd7, 0xd7, 0xaf, 187),
    (0xd7, 0xd7, 0xd7, 188),
    (0xd7, 0xd7, 0xff, 189),
    (0xd7, 0xff, 0x00, 190),
    (0xd7, 0xff, 0x5f, 191),
    (0xd7, 0xff, 0x87, 192),
    (0xd7, 0xff, 0xaf, 193),
    (0xd7, 0xff, 0xd7, 194),
    (0xd7, 0xff, 0xff, 195),
    (0xff, 0x00, 0x00, 196),
    (0xff, 0x00, 0x5f, 197),
    (0xff, 0x00, 0x87, 198),
    (0xff, 0x00, 0xaf, 199),
    (0xff, 0x00, 0xd7, 200),
    (0xff, 0x00, 0xff, 201),
    (0xff, 0x5f, 0x00, 202),
    (0xff, 0x5f, 0x5f, 203),
    (0xff, 0x5f, 0x87, 204),
    (0xff, 0x5f, 0xaf, 205),
    (0xff, 0x5f, 0xd7, 206),
    (0xff, 0x5f, 0xff, 207),
    (0xff, 0x87, 0x00, 208),
    (0xff, 0x87, 0x5f, 209),
    (0xff, 0x87, 0x87, 210),
    (0xff, 0x87, 0xaf, 211),
    (0xff, 0x87, 0xd7, 212),
    (0xff, 0x87, 0xff, 213),
    (0xff, 0xaf, 0x00, 214),
    (0xff, 0xaf, 0x5f, 215),
    (0xff, 0xaf, 0x87, 216),
    (0xff, 0xaf, 0xaf, 217),
    (0xff, 0xaf, 0xd7, 218),
    (0xff, 0xaf, 0xff, 219),
    (0xff, 0xd7, 0x00, 220),
    (0xff, 0xd7, 0x5f, 221),
    (0xff, 0xd7, 0x87, 222),
    (0xff, 0xd7, 0xaf, 223),
    (0xff, 0xd7, 0xd7, 224),
    (0xff, 0xd7, 0xff, 225),
    (0xff, 0xff, 0x00, 226),
    (0xff, 0xff, 0x5f, 227),
    (0xff, 0xff, 0x87, 228),
    (0xff, 0xff, 0xaf, 229),
    (0xff, 0xff, 0xd7, 230),
    (0xff, 0xff, 0xff, 231),

    # Various gray values
    (0x08, 0x08, 0x08, 232),
    (0x12, 0x12, 0x12, 233),
    (0x1c, 0x1c, 0x1c, 234),
    (0x26, 0x26, 0x26, 235),
    (0x30, 0x30, 0x30, 236),
    (0x3a, 0x3a, 0x3a, 237),
    (0x44, 0x44, 0x44, 238),
    (0x4e, 0x4e, 0x4e, 239),
    (0x58, 0x58, 0x58, 240),
    (0x62, 0x62, 0x62, 241),
    (0x6c, 0x6c, 0x6c, 242),
    (0x76, 0x76, 0x76, 243),
    (0x80, 0x80, 0x80, 244),
    (0x8a, 0x8a, 0x8a, 245),
    (0x94, 0x94, 0x94, 246),
    (0x9e, 0x9e, 0x9e, 247),
    (0xa8, 0xa8, 0xa8, 248),
    (0xb2, 0xb2, 0xb2, 249),
    (0xbc, 0xbc, 0xbc, 250),
    (0xc6, 0xc6, 0xc6, 251),
    (0xd0, 0xd0, 0xd0, 252),
    (0xda, 0xda, 0xda, 253),
    (0xe4, 0xe4, 0xe4, 254),
    (0xee, 0xee, 0xee, 255)
]

# Tiling options based on which pixels in a 2x2 grid are filled
# First two elements are the filled elements
# The second two are the shape and its inverse
tile_map = [

    ((1, 1),
     (1, 1), u'\u2588', u'\u2588'), # |█| Full block

    ((0, 0),
     (1, 1), u'\u2584', u'\u2580'), # |▄| Lower half block

    ((0, 1),
     (0, 1), u'\u2590', u'\u258C'), # |▐| Right half block

    ((0, 1),
     (1, 0), u'\u259E', u'\u259A'), # |▞| Quadrant upper right and lower left

    ((0, 1),
     (1, 1), u'\u259F', u'\u2598'), # |▟| Quadrant upper right and lower left and lower right

    ((1, 0),
     (0, 1), u'\u259A', u'\u259E'), # |▚| Quadrant upper left and lower right

    ((1, 0),
     (1, 0), u'\u258C', u'\u2590'), # |▌| Left half block

    ((1, 0),
     (1, 1), u'\u2599', u'\u259D'), # |▙| Quadrant upper left and lower left and lower right

    ((1, 1),
     (0, 0), u'\u2580', u'\u2584'), # |▀| Upper half block

    ((1, 1),
     (0, 1), u'\u259C', u'\u2596'), # |▜| Quadrant upper left and upper right and lower right

    ((1, 1),
     (1, 0), u'\u259B', u'\u2597')  # |▛| Quadrant upper left and upper right and lower left
]

def distance(a, b):
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2 + (a[2] - b[2])**2)

def best_match(px):
    # Search through our list and choose the one with the smallest distance
    best = colour_map[0]
    best_distance = distance((0,0,0),(255,255,255))

    for c in colour_map:
        d = distance(px, c)

        if d < best_distance:
            best = c
            best_distance = d

    return best

def best_grouping(tl, tr, bl, br):

    fg = (0, 0, 0)
    bg = (0, 0, 0)
    best = None
    best_value = sys.float_info.max

    # Go through each of our possible tile mappings
    for g in tile_map:
        group_a = []
        group_b = []

        # Sort each element into the appropriate group
        (group_a if g[0][0] == 1 else group_b).append(tl)
        (group_a if g[0][1] == 1 else group_b).append(tr)
        (group_a if g[1][0] == 1 else group_b).append(bl)
        (group_a if g[1][1] == 1 else group_b).append(br)

        # Calculate the average of our groups
        avg_a = tuple(map(lambda y: sum(y) / float(len(y)), zip(*group_a)))
        avg_b = tuple(map(lambda y: sum(y) / float(len(y)), zip(*group_b)))

        # Subtract our mean from the values
        group_a = [(v[0] - avg_a[0], v[1] - avg_a[1], v[2] - avg_a[2]) for v in group_a]
        group_b = [(v[0] - avg_b[0], v[1] - avg_b[1], v[2] - avg_b[2]) for v in group_b]

        # Take the sum of squares of these values
        total = 0
        for v in group_a + group_b:
            total += v[0]**2 + v[1]**2 + v[2]**2

        if total < best_value:
            best_value = total
            best = g
            fg = avg_a
            bg = avg_b

    # If one group wasn't filled (the 1,1,1,1 group) set fg and bg the same
    fg = fg if fg else bg
    bg = bg if bg else fg

    # Always favour the lighter color as the foreground since it helps with some terminals
    if sum(fg) > sum(bg):
        return (fg, bg, best[2], best_value)
    else:
        return (bg, fg, best[3], best_value)

# Make our colour using our colour map
def colour(tl, tr, bl, br):
    # We have to pick two colours that best represent this set of pixels
    # and we can arrange them into any 2x2 grid. so we will try them all
    # and see which one results in the lowest error

    # Groupings
    value = best_grouping(tl, tr, bl, br)

    # Foreground colour
    fg = best_match(value[0])[3]
    # Background colour
    bg = best_match(value[1])[3]
    # Group character
    ch = value[2]

    return (fg, bg, ch)


# Convert our image into an ansi coded string
def ampscii(src, unicode=True):

    # Load the image
    im = Image.open(src)
    pix = im.load()

    # Loop through our image pixels in 2x2 blocks and get the best match for colours
    # Since our resolution is double in the x as y, we jump 2x as fast in that direction
    rows = []
    for y in range(1, im.height - 1, 4):
        row = []
        for x in range(1, im.width - 1, 2):
            tl = pix[x + 0, y + 0]
            tr = pix[x + 1, y + 0]
            bl = pix[x + 0, y + 1]
            br = pix[x + 1, y + 1]

            row.append(colour(tl, tr, bl, br))
        rows.append(row)

    # Now convert those rows into a string
    output = u''

    for l in rows:
        fg = None
        bg = None
        for v in l:

            # Change foreground colour
            if v[0] != fg:
                fg = v[0]
                output += u'\x1b[38;5;{}m'.format(fg)

            # Change background colour
            if v[1] != bg:
                bg = v[1]
                output += u'\x1b[48;5;{}m'.format(bg)

            # TODO check if we can flip the FG and BG colours to not change

            # Append our character
            if (unicode):
                output += v[2]
            else:
                output += '#'

        # Reset and make a new line
        output += u'\x1b[0m\n'

    return output
